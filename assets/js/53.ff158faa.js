(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{367:function(e,a,v){"use strict";v.r(a);var _=v(42),s=Object(_.a)({},(function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"android中的消息机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#android中的消息机制"}},[e._v("#")]),e._v(" Android中的消息机制")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("本节内容：")]),e._v(" "),v("p",[e._v("一．什么是Handler；")]),e._v(" "),v("p",[e._v("二．Handler、Looper和MessageQueue的基本原理；")]),e._v(" "),v("p",[e._v("三．通过Handler实现线程间的通信；")]),e._v(" "),v("p",[e._v("四．初步分析Handler的工作原理；")])]),e._v(" "),v("h2",{attrs:{id:"一．什么是handler？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一．什么是handler？"}},[e._v("#")]),e._v(" 一．什么是Handler？")]),e._v(" "),v("p",[e._v("Handler实际上就是一个处理器，在Android官方文档中并未对其有过精确的定义，")]),e._v(" "),v("p",[e._v("但我们可以将Handler、Looper和MessageQueue看作成一个整体，")]),e._v(" "),v("p",[e._v("其构成的这个整体就是Android中最重要的消息传递和消息处理机制。")]),e._v(" "),v("p",[e._v("在程序中，Handler是个类，所在的包结构：android.os.Handler;这里的包名os指的是：operation syster，即操作系统。")]),e._v(" "),v("h2",{attrs:{id:"二．handler、looper和messagequeue的基本原理；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二．handler、looper和messagequeue的基本原理；"}},[e._v("#")]),e._v(" 二．Handler、Looper和MessageQueue的基本原理；")]),e._v(" "),v("p",[e._v("Handler不断的将消息对象放入到消息队列里面，")]),e._v(" "),v("p",[e._v("Looper不断的向消息队列里面取消息对象（如果消息队列里面没有消息对象的话，Looper就处于等待的状态），取出后再交给Handler来处理。")]),e._v(" "),v("p",[e._v("如下图所示：")]),e._v(" "),v("p",[v("img",{attrs:{src:"/documents/img/android/05.png",alt:"1"}})]),e._v(" "),v("h2",{attrs:{id:"三．通过handler实现线程间的通信；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三．通过handler实现线程间的通信；"}},[e._v("#")]),e._v(" 三．通过Handler实现线程间的通信；")]),e._v(" "),v("h3",{attrs:{id:"_1-在主线程当中定义一个类继承handler并实现handlermessage-方法；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-在主线程当中定义一个类继承handler并实现handlermessage-方法；"}},[e._v("#")]),e._v(" 1.在主线程当中定义一个类继承Handler并实现handlerMessage()方法；")]),e._v(" "),v("h3",{attrs:{id:"_2-在worker-thread中通过handler发送消息。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-在worker-thread中通过handler发送消息。"}},[e._v("#")]),e._v(" 2.在Worker Thread中通过Handler发送消息。")]),e._v(" "),v("p",[e._v("即在线程的"),v("code",[e._v("run()")]),e._v("方法中创建消息对象并使用Handler发送该对象。代码如下:")]),e._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")]),e._v(" msg "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" handler"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("obtainMessage")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nmsg"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("属性 "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" 要赋得值；例如：msg"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("obj"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("””"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br")])]),v("p",[v("code",[e._v("handler.sendMessage(msg);")]),e._v("\n这句代码相当于做了四件事情：")]),e._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),v("p",[e._v("(1)这句代码将消息对象首先发送(放置)到消息队列当中；")]),e._v(" "),v("p",[e._v("(2)Looper将会从消息队列当中将消息对象取出；")]),e._v(" "),v("p",[e._v("(3)Looper将会找到与消息对象对应的Handler对象；")]),e._v(" "),v("p",[e._v("(4)Looper将会调用Handler对象的handlerMessage(Message msg)方法，用于处理消息对象。")])]),e._v(" "),v("p",[e._v("注意："),v("code",[e._v("sendMessage()")]),e._v("方法无论是在主线程当中还是在工作线程当中发送都是可以的。")]),e._v(" "),v("p",[e._v("这样就解决了工作线程与主线程之间的通信问题。")]),e._v(" "),v("h2",{attrs:{id:"四．初步分析handler的工作原理；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四．初步分析handler的工作原理；"}},[e._v("#")]),e._v(" 四．初步分析Handler的工作原理；")]),e._v(" "),v("p",[e._v("结合上面的代码案例及Android源码，")]),e._v(" "),v("h3",{attrs:{id:"_1-handler-obtainmessage-这句代码的工作是这样的："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-handler-obtainmessage-这句代码的工作是这样的："}},[e._v("#")]),e._v(" 1."),v("code",[e._v("handler.obtainMessage()")]),e._v("这句代码的工作是这样的：")]),e._v(" "),v("p",[e._v("(1)首先在"),v("code",[e._v("obtainMessage()")]),e._v("方法中执行"),v("code",[e._v("obtain(this)")]),e._v("这句代码，")]),e._v(" "),v("p",[e._v("即：调用了"),v("code",[e._v("obtain(Handler handler)")]),e._v("方法，所传参数"),v("code",[e._v("this")]),e._v("指的是当前的Handler对象。")]),e._v(" "),v("p",[e._v("(2)在"),v("code",[e._v("obtain(Handler handler)")]),e._v("方法中首先调用了无参的"),v("code",[e._v("obtain()")]),e._v("方法，该方法创建了一个Message对象并返出，")]),e._v(" "),v("p",[e._v("因此在"),v("code",[e._v("obtain(Handler handler)")]),e._v("方法中得到了一个Message对象，然后将传进来的参数（也就是当前的Handler对象）赋值给这个Message对象的"),v("code",[e._v("target")]),e._v("属性。")]),e._v(" "),v("p",[e._v("这样就在"),v("code",[e._v("Handler")]),e._v("与"),v("code",[e._v("Message")]),e._v("之间建立了对应关系，这种对应关系是一对多的关系，")]),e._v(" "),v("p",[e._v("即：一个"),v("code",[e._v("Handler")]),e._v("可以生成多个"),v("code",[e._v("Message")]),e._v("对象。")]),e._v(" "),v("p",[e._v("在这里总结为一句话：使用"),v("code",[e._v("Handler")]),e._v("生成"),v("code",[e._v("Message")]),e._v("，所生成的"),v("code",[e._v("Message")]),e._v("对象的"),v("code",[e._v("target")]),e._v("属性就是该"),v("code",[e._v("Handler")]),e._v("对象。")]),e._v(" "),v("h3",{attrs:{id:"_2-要想在worker-thread中使用looper的方法，"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-要想在worker-thread中使用looper的方法，"}},[e._v("#")]),e._v(" 2.要想在Worker Thread中使用Looper的方法，")]),e._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),v("p",[e._v("首先调用"),v("code",[e._v("Looper.prepare()")]),e._v("方法；")]),e._v(" "),v("p",[e._v("然后生成一个Handler对象,调用其构造方法:")]),e._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[e._v("mHandler "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Handler")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" handlerMessage（"),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")]),e._v(" msg）｛\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//这里处理传入的消息")]),e._v("\n    ｝\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br")])]),v("p",[e._v("然后再调用"),v("code",[e._v("Looper.loop()")]),e._v("方法。")])]),e._v(" "),v("p",[e._v("(1)先从"),v("code",[e._v("Looper.prepare()")]),e._v("方法说起，这个方法就是")]),e._v(" "),v("p",[e._v("建了一个"),v("code",[e._v("Looper")]),e._v("对象作为值、以当前线程为键然后存入线程本地变量"),v("code",[e._v("sThreadLocal")]),e._v("(即："),v("code",[e._v("ThreadLocal")]),e._v(")\n，")]),e._v(" "),v("p",[e._v("这样就将"),v("code",[e._v("Looper")]),e._v("与"),v("code",[e._v("Thread")]),e._v("建立了对应关系(一个线程只能有一个"),v("code",[e._v("Looper")]),e._v("对象)。")]),e._v(" "),v("p",[e._v("而在"),v("code",[e._v("Looper")]),e._v("对象的构造方法中又创建了一个"),v("code",[e._v("MessageQueue")]),e._v("对象赋值给成员变量"),v("code",[e._v("mQueue")]),e._v("，并取得当前线程的对象赋值给成员变量"),v("code",[e._v("mThread")]),e._v("，\n(这样就将"),v("code",[e._v("MessageQueue")]),e._v("与"),v("code",[e._v("Thread")]),e._v("建立了对应关系)；")]),e._v(" "),v("p",[e._v("(2)然后在"),v("code",[e._v("Handler")]),e._v("的构造方法中调用"),v("code",[e._v("Looper.myLooper（）")])]),e._v(" "),v("p",[e._v("方法根据线程本地变量"),v("code",[e._v("sThreadLocal")]),e._v("取出了"),v("code",[e._v("Looper")]),e._v("对象赋值给"),v("code",[e._v("Handler")]),e._v("的成员变量"),v("code",[e._v("mLooper")]),e._v("，该对象又取出了其属性"),v("code",[e._v("mQueue")]),e._v("(也就是"),v("code",[e._v("MessageQueue")]),e._v("对象)赋值给了"),v("code",[e._v("Handler")]),e._v("的成员变量"),v("code",[e._v("mQueue")]),e._v("。")]),e._v(" "),v("p",[e._v("截止到现在，"),v("code",[e._v("Looper")]),e._v("、"),v("code",[e._v("MessageQueue")]),e._v("、"),v("code",[e._v("Handler")]),e._v("三者之间已建立起了一一对应的关系，")]),e._v(" "),v("p",[e._v("即一个"),v("code",[e._v("Handler")]),e._v("对应一个"),v("code",[e._v("Looper")]),e._v("对象，一个"),v("code",[e._v("Looper")]),e._v("对应一个"),v("code",[e._v("MessageQueue")]),e._v("对象。")]),e._v(" "),v("p",[e._v("(3)调用"),v("code",[e._v("Looper.loop()")]),e._v("方法从消息队列中循环的向外取出数据。")]),e._v(" "),v("p",[e._v("该方法中，首先获取到消息队列的对象"),v("code",[e._v("mQueue")]),e._v("。然后执行"),v("code",[e._v("for(;;)")]),e._v("循环。")]),e._v(" "),v("p",[e._v("该方法中的"),v("code",[e._v("for(;;)")]),e._v("同"),v("code",[e._v("while(true)")]),e._v("\n循环一样，都是死循环，直到遇到"),v("code",[e._v("break")]),e._v("才停止。")]),e._v(" "),v("p",[e._v("在这个循环中，首先取Message对象(通过"),v("code",[e._v("MessageQueue")]),e._v("对象的"),v("code",[e._v("next()")]),e._v("方法)并赋值给局部变量"),v("code",[e._v("msg")]),e._v("，如果没有就处于阻塞状态，")]),e._v(" "),v("p",[e._v("如果有且Message对象不为"),v("code",[e._v("null")]),e._v("的时候，调用"),v("code",[e._v("msg.target.dispatchMessage(msg)")]),e._v("方法并将当前的消息对象作为参数传递，因为"),v("code",[e._v("msg.target")]),e._v("得到的是"),v("code",[e._v("Handler")]),e._v("对象，那么这里其实是调用了"),v("code",[e._v("Handler的dispatchMessage(msg)")]),e._v("方法，在该方法中又调用了"),v("code",[e._v("handlerMessage(Message msg)")]),e._v("方法来处理消息对象。")]),e._v(" "),v("h3",{attrs:{id:"补充-关于threadlocal；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-关于threadlocal；"}},[e._v("#")]),e._v(" 补充: 关于ThreadLocal；")]),e._v(" "),v("p",[e._v("ThreadLocal是java当中跟线程有关的一个类，严格意义上来讲，应将它叫做线程本地变量，")]),e._v(" "),v("p",[e._v("那么什么叫做线程本地变量？其实就是保存与当前线程相对应的值的变量。")]),e._v(" "),v("p",[e._v("ThreadLocal可以想象成是一个特殊的HashMap，只不过HashMap的键值都是obj对象，而ThreadLocal的键则是线程对象。")]),e._v(" "),v("p",[e._v("当执行ThreadLocal对象的set(Object obj)方法时，")]),e._v(" "),v("p",[e._v("将会存入一个以当前线程对象为键、以所传入参数为值的键值对。")]),e._v(" "),v("p",[e._v("执行ThreadLocal对象的get()方法（该方法无参），")]),e._v(" "),v("p",[e._v("将会根据当前线程对象为键，取出与之对应的值。")]),e._v(" "),v("p",[e._v("也就是说，当执行set(Object obj)方法时，实际上就是向ThreadLocal当中添加一个键值对。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[e._v("键")]),e._v(" "),v("th",[e._v("值")])])]),e._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[e._v("线程4")]),e._v(" "),v("td",[e._v("值4")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[e._v("线程3")]),e._v(" "),v("td",[e._v("值3")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[e._v("线程2")]),e._v(" "),v("td",[e._v("值2")])]),e._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[e._v("线程1")]),e._v(" "),v("td",[e._v("值1")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);